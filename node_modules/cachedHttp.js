var http = require('http');
var fs = require('fs');
var file = require('file.js');
var dir = require('dir.js');

function load (host, path, callback, cacheName) {
    dir(__dirname + '/../tmp-data/', function () {
        
        var dirName = __dirname + '/../tmp-data/' + ( cacheName ? cacheName + '/': '');
        dir(dirName, function () {
            var fileName = dirName + encodeURIComponent(host + path);
            fs.stat(fileName, function (err, stat) {
                if (!err && stat.isFile()) {
                    file.read(fileName, function (data) {
                        //console.log('load file', fileName)
                        callback(data);
                    })
                } else {
                    makeHttpRequest(host, path, function (data) {
                        if (callback(data)) {
                            console.log('loaded by http', fileName)
                            file.write(fileName, data);
                        } else {
                            console.log('load http', host, path)
                            console.log('wrong response')
                            console.log(data)
                        }
                    })
                }
            })
        })

    });
}

function makeHttpRequest (host, path, callback) {
    var options = {
        host: host,
        port: 80,
        path: path
    };

    var bufferArray = [], bufferArrayCommonLength = 0;

    http.get(options, function(res) {

        res.on('data', function (data) {
            // нельзя приводить к строке куски буфера, нужно сначала скелить буферы, потом приводить
            // иначе могут побиться utf символы, которые разобьются на два куска
            bufferArray.push(data);
            bufferArrayCommonLength += data.length;
        })

        res.on('end', function () {

            var currentIndex = 0;
            var resBuffer = new Buffer(bufferArrayCommonLength);
            bufferArray.forEach(function (buffer) {
                buffer.copy(resBuffer, currentIndex, 0, buffer.length);
                currentIndex += buffer.length;
            });

            callback(resBuffer.toString());
        })
    }).on('error', function(e) {
        console.log('load http', host, path)
        console.log("http load error: " + e.message);
    });
}

// Ограничивает количество параллельно исполняемых действий
var executer = new (require('executer.js'))(10)

exports.load = function (host, path, callback, cacheName) {
    executer.add(function (completeCallback) {
        load(host, path, function () {
            completeCallback();
            if (callback) {
                return callback.apply(null, arguments);
            }
        }, cacheName)
    });
};
